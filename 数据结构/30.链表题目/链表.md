以下是按照您的要求重新编排后的笔记内容，去除了小表情并使用大小标题进行结构化：

---

# 链表相关题目

## 一、反转链表

### 1. 题目描述

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

![img.png](img/img.png)

> 输入：`head = [1,2,3,4,5]`  
> 输出：`[5,4,3,2,1]`

---

### 2. 解法一：头插法

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head == null) return null;

        ListNode new_head = null;
        ListNode p = head;

        while(p != null) {
            new_head = new ListNode(p.val, new_head);
            p = p.next;
        }

        return new_head;
    }
}
```


#### 时间复杂度分析：
- 时间复杂度：O(n)，其中 n 是链表的长度。我们需要遍历整个链表一次。
- 空间复杂度：O(n)，需要创建新的节点来构建反转后的链表。

---

### 3. 解法二：递归

```java
public ListNode reverseList(ListNode head) {
    if(head == null || head.next == null) return head;

    ListNode lastListNode = reverseList(head.next);
    head.next.next = head;
    head.next = null;

    return lastListNode;
}
```


#### 时间复杂度分析：
- 时间复杂度：O(n)，其中 n 是链表的长度。每个节点都会被访问一次。
- 空间复杂度：O(n)，由于递归调用栈的深度等于链表长度，所以空间复杂度为 O(n)。

---

### 4. 解法三：迭代法

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode curr = head;
        ListNode next = null;
        while (curr != null) {
            next = curr.next;
            curr.next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    }
}
```


#### 时间复杂度分析：
- 时间复杂度：O(n)，其中 n 是链表的长度。我们需要遍历整个链表一次。
- 空间复杂度：O(1)，只使用了常数级别的额外空间，没有创建新的节点。

#### 解法思路：
- 使用三个指针：`prev`（前一个节点）、`curr`（当前节点）、[next](file://D:\Users\32147\Documents\Obsidian%20Vault\Java-Algorithms\DemoCode\src\main\java\leetcode01\LeetCode02.java#L27-L27)（下一个节点）
- 在每次迭代中，将当前节点的 [next](file://D:\Users\32147\Documents\Obsidian%20Vault\Java-Algorithms\DemoCode\src\main\java\leetcode01\LeetCode02.java#L27-L27) 指针指向前一个节点，实现链表方向的反转
- 这是最优解法，既高效又节省空间

--- 

以上是整理后的内容，保留了原有结构和图片链接，同时去除了所有小表情符号。