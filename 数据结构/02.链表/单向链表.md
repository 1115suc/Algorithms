# 一、单向链表

## 1. 链表概述

在计算机科学中，链表是数据元素的线性集合，其每个元素都指向下一个元素，元素存储上并不连续

> In computer science, a **linked list** is a linear collection of data elements whose order is not given by their physical placement in memory. Instead, each element points to the next.

### 1.1 链表分类

* **单向链表**，每个元素只知道其下一个元素是谁
  ![image-20221110083407176](imgs\image-20221110083407176.png)

* **双向链表**，每个元素知道其上一个元素和下一个元素
  ![image-20221110083427372](imgs\image-20221110083427372.png)

* **循环链表**，通常的链表尾节点 `tail` 指向的都是 `null`，而循环链表的 `tail` 指向的是头节点 `head`
  ![image-20221110083538273](imgs\image-20221110083538273.png)

### 1.2 哨兵节点

链表内还有一种特殊的节点称为哨兵（Sentinel）节点，也叫做哑元（Dummy）节点，它不存储数据，通常用作头尾，用来简化边界判断，如下图所示
![image-20221110084611550](imgs\image-20221110084611550.png)

### 1.3 性能分析

**随机访问性能**:
根据 index 查找，时间复杂度 $O(n)$

**插入或删除性能**:
* 起始位置：$O(1)$
* 结束位置：如果已知 tail 尾节点是 $O(1)$，不知道 tail 尾节点是 $O(n)$
* 中间位置：根据 index 查找时间 + $O(1)$

## 2. 单向链表实现

### 2.1 单向链表类 `SinglyLinkedList`

根据单向链表的定义，首先定义一个存储 `value` 和 [next](file://D:\Users\32147\Documents\Obsidian%20Vault\Java-Algorithms\DemoCode\src\main\java\leetcode01\LeetCode02.java#L27-L27) 指针的类 `Node`，和一个描述头部节点的引用

```java
public class SinglyLinkedList {
    
    private Node head; // 头部节点
    
    private static class Node { // 节点类
        int value;
        Node next;

        public Node(int value, Node next) {
            this.value = value;
            this.next = next;
        }
    }
}
```


#### 2.1.1 设计要点：
* `Node` 定义为内部类，是为了对外**隐藏**实现细节，没必要让类的使用者关心 `Node` 结构
* 定义为 `static` 内部类，是因为 `Node` **不需要**与 `SinglyLinkedList` 实例相关，多个 `SinglyLinkedList` 实例能共用 `Node` 类定义

### 2.2 头部添加

```java
public class SinglyLinkedList {
    public void addFirst(int value) {
		this.head = new Node(value, this.head);
    }
}
```


#### 2.2.1 执行逻辑：
* 如果 `this.head == null`，新增节点指向 `null`，并作为新的 `this.head`
* 如果 `this.head != null`，新增节点指向原来的 `this.head`，并作为新的 `this.head`
  * 注意赋值操作执行顺序是从右到左

### 2.3 遍历方式

#### 2.3.1 while 遍历

```java
public class SinglyLinkedList {
    public void loop() {
        Node curr = this.head;
        while (curr != null) {
            curr = curr.next;
        }
    }
}
```


#### 2.3.2 for 遍历

```java
public class SinglyLinkedList {
    public void loop() {
        for (Node curr = this.head; curr != null; curr = curr.next) {
            // 做一些事
        }
    }
}
```


#### 2.3.3 特点说明：
* 以上两种遍历都可以把**要做的事**以 `Consumer` 函数的方式传递进来
  * `Consumer` 的规则是**一个参数**，**无返回值**，因此像 `System.out::println` 方法等都是 `Consumer`
  * 调用 `Consumer` 时，将当前节点 `curr.value` 作为参数传递给它

#### 2.3.4 迭代器遍历

```java
public class SinglyLinkedList implements Iterable<Integer> {
    // ...
    private class NodeIterator implements Iterator<Integer> {
        Node curr = head;
        
        public boolean hasNext() {
            return curr != null;
        }

        public Integer next() {
            int value = curr.value;
            curr = curr.next;
            return value;
        }
    }
    
    public Iterator<Integer> iterator() {
        return new NodeIterator();
    }
}
```


#### 2.3.5 关键要点：
* `hasNext` 用来判断是否还有必要调用 [next](file://D:\Users\32147\Documents\Obsidian%20Vault\Java-Algorithms\DemoCode\src\main\java\leetcode01\LeetCode02.java#L27-L27)
* [next](file://D:\Users\32147\Documents\Obsidian%20Vault\Java-Algorithms\DemoCode\src\main\java\leetcode01\LeetCode02.java#L27-L27) 做两件事
  * 返回当前节点的 `value`
  * 指向下一个节点
* `NodeIterator` 要定义为**非 `static` 内部类**，是因为它与 `SinglyLinkedList` 实例相关，是对某个 `SinglyLinkedList` 实例的迭代

#### 2.3.6 递归遍历

```java
public class SinglyLinkedList implements Iterable<Integer> {
    public void loop() {
        recursion(this.head);
    }

    private void recursion(Node curr) {
        if (curr == null) {
            return;
        }
        // 前面做些事
        recursion(curr.next);
        // 后面做些事
    }
}
```

### 2.4 尾部添加

```java
public class SinglyLinkedList {
    // ...
    private Node findLast() {
        if (this.head == null) {
            return null;
        }
        Node curr;
        for (curr = this.head; curr.next != null; ) {
            curr = curr.next;
        }
        return curr;
    }
    
    public void addLast(int value) {
        Node last = findLast();
        if (last == null) {
            addFirst(value);
            return;
        }
        last.next = new Node(value, null);
    }
}
```


#### 2.4.1 实现要点：
* 注意，找最后一个节点，终止条件是 `curr.next == null`
* 分成两个方法是为了代码清晰，而且 `findLast()` 之后还能复用

#### 2.4.2 尾部添加多个

```java
public class SinglyLinkedList {
    // ...
	public void addLast(int first, int[] rest) {
        
        Node sublist = new Node(first, null);
        Node curr = sublist;
        for (int value : rest) {
            curr.next = new Node(value, null);
            curr = curr.next;
        }
        
        Node last = findLast();
        if (last == null) {
            this.head = sublist;
            return;
        }
        last.next = sublist;
    }
}
```


#### 2.4.3 实现思路：
* 先串成一串 `sublist`
* 再作为一个整体添加

### 2.5 根据索引获取

```java
public class SinglyLinkedList {
    // ...
	private Node findNode(int index) {
        int i = 0;
        for (Node curr = this.head; curr != null; curr = curr.next, i++) {
            if (index == i) {
                return curr;
            }
        }
        return null;
    }
    
    private IllegalArgumentException illegalIndex(int index) {
        return new IllegalArgumentException(String.format("index [%d] 不合法%n", index));
    }
    
    public int get(int index) {
        Node node = findNode(index);
        if (node != null) {
            return node.value;
        }
        throw illegalIndex(index);
    }
}
```


#### 2.5.1 设计思想：
* 同样，分方法可以实现复用

### 2.6 插入操作

```java
public class SinglyLinkedList {
    // ...
	public void insert(int index, int value) {
        if (index == 0) {
            addFirst(value);
            return;
        }
        Node prev = findNode(index - 1); // 找到上一个节点
        if (prev == null) { // 找不到
            throw illegalIndex(index);
        }
        prev.next = new Node(value, prev.next);
    }
}
```


#### 2.6.1 关键点：
* 插入包括下面的删除，都必须找到上一个节点

### 2.7 删除操作

```java
public class SinglyLinkedList {
    // ...
	public void remove(int index) {
        if (index == 0) {
            if (this.head != null) {
                this.head = this.head.next;
                return;
            } else {
                throw illegalIndex(index);
            }
        }
        Node prev = findNode(index - 1);
        Node curr;
        if (prev != null && (curr = prev.next) != null) {
            prev.next = curr.next;
        } else {
            throw illegalIndex(index);
        }
    }
}
```


#### 2.7.1 处理逻辑：
* 第一个 [if](file://D:\Users\32147\Documents\Obsidian%20Vault\Java-Algorithms\数据结构\20.递归\imgs\2.gif) 块对应着 `removeFirst` 情况
* 最后一个 [if](file://D:\Users\32147\Documents\Obsidian%20Vault\Java-Algorithms\数据结构\20.递归\imgs\2.gif) 块对应着至少得两个节点的情况
  * 不仅仅判断上一个节点非空，还要保证当前节点非空