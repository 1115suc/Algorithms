# 环形链表(双向环形链表带哨兵)

## 一、链表概述

环形链表是一种特殊的链表结构，其中最后一个节点的指针指向第一个节点，形成一个闭环。双向环形链表在此基础上增加了前向指针，使得可以在两个方向上遍历。

### 1. 哨兵节点设计

双向环形链表使用单个哨兵节点设计：

- 一个哨兵节点既是头节点也是尾节点
- 哨兵节点的存在简化了插入和删除操作的边界处理
- 整个链表形成一个完整的环状结构

![image-20221229144232651](imgs/image-20221229144232651.png)

![image-20221229143756065](imgs/image-20221229143756065.png)

![image-20221229153338425](imgs/image-20221229153338425.png)

---

## 二、环形链表实现

### 1. 环形链表类 `DoublyLinkedListSentinel`

```java
public class DoublyLinkedListSentinel implements Iterable<Integer> {

    private final Node sentinel = new Node(null, -1, null); // 哨兵

    public DoublyLinkedListSentinel() {
        sentinel.next = sentinel;
        sentinel.prev = sentinel;
    }

    static class Node {
        Node prev;
        int value;
        Node next;

        public Node(Node prev, int value, Node next) {
            this.prev = prev;
            this.value = value;
            this.next = next;
        }
    }
}
```


### 2. 核心设计特点

#### 2.1 初始化设计

- 使用单个哨兵节点 `sentinel`
- 初始时 `sentinel.next` 和 `sentinel.prev` 都指向自身，形成一个自循环
- 这样无论链表为空还是非空，操作逻辑都是一致的

#### 2.2 节点类 `Node`

- 包含三个字段：`prev`(指向前驱)、`value`(存储值)、[next](file://D:\Users\32147\Documents\Obsidian%20Vault\Java-Algorithms\DemoCode\src\main\java\leetcode01\LeetCode02.java#L27-L27)(指向后继)
- 构造函数同时设置前驱和后继引用

### 3. 环形结构特性

环形链表的关键在于哨兵节点的初始化：

![image-20221229143756065](imgs/image-20221229143756065.png)

- 哨兵节点的 [next](file://D:\Users\32147\Documents\Obsidian%20Vault\Java-Algorithms\DemoCode\src\main\java\leetcode01\LeetCode02.java#L27-L27) 和 `prev` 都指向自己
- 当插入第一个元素时，该元素会被插入到哨兵和哨兵之间
- 形成一个完整的环：哨兵 → 新节点 → 哨兵

### 4. 基本操作实现

#### 4.1 头部操作

```java
/**
 * 添加到第一个
 * @param value 待添加值
 */
public void addFirst(int value) {
    Node next = sentinel.next;
    Node prev = sentinel;
    Node added = new Node(prev, value, next);
    prev.next = added;
    next.prev = added;
}
```


#### 4.2 尾部操作

```java
/**
 * 添加到最后一个
 * @param value 待添加值
 */
public void addLast(int value) {
    Node prev = sentinel.prev;
    Node next = sentinel;
    Node added = new Node(prev, value, next);
    prev.next = added;
    next.prev = added;
}
```


##### 4.2.1 实现要点：

- `addFirst` 在哨兵节点后插入新节点
- `addLast` 在哨兵节点前插入新节点（即链表末尾）
- 由于是环形结构，这两种操作本质上是在同一个位置的不同表述

### 5. 删除操作实现

#### 5.1 头部删除

```java
/**
 * 删除第一个
 */
public void removeFirst() {
    Node removed = sentinel.next;
    if (removed == sentinel) {
        throw new IllegalArgumentException("非法");
    }
    Node a = sentinel;
    Node b = removed.next;
    a.next = b;
    b.prev = a;
}
```


#### 5.2 尾部删除

```java
/**
 * 删除最后一个
 */
public void removeLast() {
    Node removed = sentinel.prev;
    if (removed == sentinel) {
        throw new IllegalArgumentException("非法");
    }
    Node a = removed.prev;
    Node b = sentinel;
    a.next = b;
    b.prev = a;
}
```


#### 5.3 按值删除

```java
/**
 * 根据值删除节点
 * <p>假定 value 在链表中作为 key, 有唯一性</p>
 * @param value 待删除值
 */
public void removeByValue(int value) {
    Node removed = findNodeByValue(value);
    if (removed != null) {
        Node prev = removed.prev;
        Node next = removed.next;
        prev.next = next;
        next.prev = prev;
    }
}
```


##### 5.3.1 删除要点：

- 删除操作统一为：断开待删除节点与其前后节点的连接，重新连接前后节点
- 空链表检测：当要删除的节点就是哨兵节点时，表示链表为空

### 6. 查找操作

```java
private Node findNodeByValue(int value) {
    Node p = sentinel.next;
    while (p != sentinel) {
        if (p.value == value) {
            return p;
        }
        p = p.next;
    }
    return null;
}
```


##### 6.1 查找特点：

- 从 `sentinel.next` 开始遍历（第一个有效节点）
- 遍历终止条件是回到哨兵节点
- 这体现了环形结构的特点

### 7. 迭代器遍历

```java
@Override
public Iterator<Integer> iterator() {
    return new Iterator<>() {
        Node p = sentinel.next;

        @Override
        public boolean hasNext() {
            return p != sentinel;
        }

        @Override
        public Integer next() {
            int value = p.value;
            p = p.next;
            return value;
        }
    };
}
```


##### 7.1 遍历特点：

- 从 `sentinel.next` 开始（第一个有效节点）
- `hasNext` 判断当前节点是否为哨兵节点
- [next](file://D:\Users\32147\Documents\Obsidian%20Vault\Java-Algorithms\DemoCode\src\main\java\leetcode01\LeetCode02.java#L27-L27) 返回当前值并移动到下一节点
- 当遍历完整个链表后会回到哨兵节点，从而结束遍历

### 8. 数据结构状态演示

![image-20221229153338425](imgs/image-20221229153338425.png)

插入元素后状态：
![image-20221229154248800](imgs/image-20221229154248800.png)

### 9. 性能分析

**随机访问性能**:  
根据 index 查找，时间复杂度 $O(n)$

**插入或删除性能**:
- 起始位置：$O(1)$
- 结束位置：$O(1)$
- 中间位置：根据查找时间 + $O(1)$

**遍历性能**:
- 正向遍历：$O(n)$
- 反向遍历：$O(n)$（得益于双向链接）

### 10. 环形链表优势

1. 统一的操作逻辑：无需区分空链表和非空链表的处理
2. 高效的边界操作：头部和尾部操作都是 $O(1)$ 时间复杂度
3. 灵活的遍历方式：支持正向和反向遍历
4. 自然的循环特性：适合实现循环队列等应用场景

环形链表特别适用于需要频繁在两端进行操作且具有循环特性的场景，如缓冲区管理、任务调度等！