# 一、单向链表（哨兵）

## 1. 问题背景

观察之前单向链表的实现，发现每个方法内几乎都有判断是不是 `head` 这样的代码，现在我们将它简化掉。

---

## 2. 创建哨兵类 `SinglyLinkedListSentinel`

用一个不参与数据存储的特殊 `Node` 作为哨兵，它一般被称为哨兵或哑元，拥有哨兵节点的链表称为带头链表。

```java
public class SinglyLinkedListSentinel {
    // ...
    private Node head = new Node(Integer.MIN_VALUE, null);
}
```


### 2.1 设计要点：
* 具体存什么值无所谓，因为不会用到它的值。

加入哨兵节点后，代码会变得比较简单，先看几个工具方法：

```java
public class SinglyLinkedListSentinel {
    // 根据索引获取节点
    private Node findNode(int index) {
        int i = -1;
        for (Node curr = this.head; curr != null; curr = curr.next, i++) {
            if (i == index) {
                return curr;
            }
        }
        return null;
    }
    
    // 获取最后一个节点
    private Node findLast() {
        Node curr;
        for (curr = this.head; curr.next != null; ) {
            curr = curr.next;
        }
        return curr;
    }
}
```


### 2.2 改进说明：
* `findNode` 与之前类似，只是 `i` 初始值设置为 `-1` 对应哨兵，实际传入的 `index` 也是 $[-1, \infty)$。
* `findLast` 绝不会返回 `null` 了，就算没有其它节点，也会返回哨兵作为最后一个节点。

---

## 3. 优化后的核心方法

这样，代码简化为：

```java
public class SinglyLinkedListSentinel {
    // ...
    
    public void addLast(int value) {
        Node last = findLast();
        /*
        改动前
        if (last == null) {
            this.head = new Node(value, null);
            return;
        }
        */
        last.next = new Node(value, null);
    }
    
    public void insert(int index, int value) {
        /*
        改动前
        if (index == 0) {
            this.head = new Node(value, this.head);
            return;
        }
        */
        // index 传入 0 时，返回的是哨兵
        Node prev = findNode(index - 1);
        if (prev != null) {
            prev.next = new Node(value, prev.next);
        } else {
            throw illegalIndex(index);
        }
    }
    
    public void remove(int index) {
        /*
        改动前
        if (index == 0) {
            if (this.head != null) {
                this.head = this.head.next;
                return;
            } else {
                throw illegalIndex(index);
            }
        }
        */
        // index 传入 0 时，返回的是哨兵
        Node prev = findNode(index - 1);
        Node curr;
        if (prev != null && (curr = prev.next) != null) {
            prev.next = curr.next;
        } else {
            throw illegalIndex(index);
        }
    }
    
    public void addFirst(int value) {
        /*
        改动前
        this.head = new Node(value, this.head);
        */
		this.head.next = new Node(value, this.head.next);
        // 也可以视为 insert 的特例, 即 insert(0, value);
    }
}
```


### 3.1 优化效果：
* 对于删除，前面说了（最后一个 if 块对应着至少得两个节点的情况），现在有了哨兵，就凑足了两个节点。
* 代码更加简洁，避免了大量的边界条件判断。
