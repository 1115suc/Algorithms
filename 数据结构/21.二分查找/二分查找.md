# 二分查找算法详解

二分查找算法也称折半查找，是一种非常高效的工作于有序数组的查找算法。

---

## 一、基础版本

### 1. 需求说明

在**有序**数组 `A` 内，查找值 `target`
- 如果找到返回索引
- 如果找不到返回 `-1`

### 2. 算法步骤

| 前提 | 给定一个内含 $n$ 个元素的有序数组 $A$，满足 $A_0 \leq A_1 \leq A_2 \leq \cdots \leq A_{n-1}$，一个待查值 `target` |
|------|----------------------------------------------------------------------------------------------------------------|
| 1    | 设置 $i=0$，$j=n-1$                                                                                         |
| 2    | 如果 $i > j$，结束查找，没找到                                                                                |
| 3    | 设置 $m = \text{floor}(\frac{i+j}{2})$ ，$m$ 为中间索引，$\text{floor}$ 是向下取整（$\leq \frac{i+j}{2}$ 的最小整数） |
| 4    | 如果 $\text{target} < A_m$ 设置 $j = m - 1$，跳到第2步                                                       |
| 5    | 如果 $A_m < \text{target}$ 设置 $i = m + 1$，跳到第2步                                                       |
| 6    | 如果 $A_m = \text{target}$，结束查找，找到了                                                                  |

### 3. Java 实现

```java
public static int binarySearch(int[] a, int target) {
    int i = 0, j = a.length - 1;
    while (i <= j) {
        int m = (i + j) >>> 1;
        if (target < a[m]) {			// 在左边
            j = m - 1;
        } else if (a[m] < target) {		// 在右边
            i = m + 1;
        } else {
            return m;
        }
    }
    return -1;
}
```


#### 3.1 关键要点解析：

- `i,j` 对应着搜索区间 `[0,a.length-1]`（注意是闭合的区间）
- `i<=j` 意味着搜索区间内还有未比较的元素，`i,j` 指向的元素也可能是比较的目标
  - 思考：如果不加 `i==j` 行不行？
  - 回答：不行，因为这意味着 `i,j` 指向的元素会漏过比较
- `m` 对应着中间位置，中间位置左边和右边的元素可能不相等（差一个），不会影响结果
- 如果某次未找到，那么缩小后的区间内不包含 `m`

---

## 二、改进版本

```java
public static int binarySearch(int[] a, int target) {
    int i = 0, j = a.length - 1;
    while (i < j) {
        int m = 1 + (i + j) >>> 1;
        if (target < a[m]) {			// 在左边
            j = m;
        } else if (a[m] < target) {		// 在右边
            i = m + 1;
        } else {
            return m;
        }
    }
    return -1;
}
```


#### 2.1 关键要点解析：

- `i,j` 对应着搜索区间 `[0,a.length)`（注意是左闭右开的区间）
- `i<j` 意味着搜索区间内还有未比较的元素，`j` 指向的**一定不是**查找目标
  - 思考：为啥这次不加 `i==j` 的条件了？
  - 回答：这回 `j` 指向的不是查找目标，如果还加 `i==j` 条件，就意味着 `j` 指向的还会再次比较，找不到时，会死循环
- 如果某次要缩小右边界，那么 `j=m`，因为此时的 `m` 已经**不是**查找目标了

---

## 三、Leftmost 与 Rightmost 查找

有时候我们需要查找重复元素中最左边或最右边的那个元素。

### 3.1 示例说明：

- 对于数组 `[1, 2, 3, 4, 4, 5, 6, 7]`，查找元素4，结果是索引3
- 对于数组 `[1, 2, 4, 4, 4, 5, 6, 7]`，查找元素4，结果也是索引3，并不是最左侧的元素

### 3.2 查找最左侧元素实现：

```java
public static int binarySearchLeftmost1(int[] a, int target) {
    int i = 0, j = a.length - 1;
    while (i < j) {
        int m = (i + j) >>> 1;
        if (target <= a[m]) {
            j = m;
        } else {
            i = m + 1;
        } 
    }
    
    if (a[i] == target) return i;
    else return -1;
}
```


### 3.3 查找最右侧元素实现：

```java
public static int binarySearchRightmost1(int[] a, int target) {
    int i = 0, j = a.length - 1;
    while (i < j) {
        int m = 1 + (i + j) >>> 1;
        if (target >= a[m]) {
            i = m;
        } else {
            j = m - 1;
        }
    }
    
    if (a[j] == target) return j;
    else return -1;
}
```


这些变体对于处理存在重复元素的情况非常有用！